# 结构体

结构体中的函数必须为指针类型，与函数声明进行区分，若是指针函数，应再价格指针，如下图：

![image-20210124193352522](D:\markdown\IMG\image-20210124193352522.png)

# 指针

指针型的函数名和指针型的变量、结构体均存放在内存的堆中，程序执行完才释放内存；而一般的函数、变量、结构体存放在栈中，局部作用结束就会释放内存；

正确：![image-20210124194145635](D:\markdown\IMG\image-20210124194145635.png)

错误：![image-20210124194250154](D:\markdown\IMG\image-20210124194250154.png)

t[]和f[]为局部数组变量，放在栈区，执行完函数，释放掉内存，而函数返回值为char* (不能为char，否则返回的是数组与char类型不匹配)，指向t[]或f[]的地址，而地址里面的内容已经被清除，于是报错；

# goto语句

触发点，跳转到指定语句，该语句必须在方法及函数体内使用；

# 函数指针&指针函数

## 指针函数：

简单的来说，就是一个返回指针的函数，其本质是一个函数，而该函数的返回值是<u>一个指针</u>。

声明格式为：类型标识符 \*  函数名(参数表)

其返回值是一个 int 类型的指针，是一个地址。

注意：在调用指针函数时，需要一个同类型的指针来接收其函数的返回值。
不过也可以将其返回值定义为 void*类型，在调用的时候强制转换返回值为自己想要的类型。

## 函数指针：

其本质是一个指针变量，该指针指向这个函数。总结来说，函数指针就是指向函数的指针。
声明格式：类型说明符 (*函数名) (参数)

int (*fun)(int x,int y);

函数指针是需要把一个函数的地址赋值给它，有两种写法：

```
fun = &Function；
fun = Function;
取地址运算符&不是必需的，因为一个函数标识符就表示了它的地址，如果是函数调用，还必须包含一个圆括号括起来的参数表。
```

​      x = (*fun)(); x = fun();

## 定义不同

指针函数本质是一个函数，其返回值为指针。
函数指针本质是一个指针，其指向一个函数。

## 写法不同

指针函数：int* fun(int x,int y);
函数指针：int (*fun) (int x,int y);

可以简单粗暴的理解为，指针函数的*是属于数据类型的，而函数指针的星号是属于函数名的。
再简单一点，可以这样辨别两者：函数名带括号的就是函数指针，否则就是指针函数。

# 声明

声明是把特定标识符与计算机内存中的特定位置联系起来，变量声明和<u>函数声明</u>都是如此；

# 前缀和后缀

![image-20210130204800251](D:\markdown\IMG\image-20210130204800251.png)

![image-20210130205233446](D:\markdown\IMG\image-20210130205233446.png)

while(++shoe<18.5)，该测试条件相当于提供了一个鞋子尺码到 18的表。如果使用shoe++而不是++shoe，尺码表会增加到19，因为shoe会与18.5进行比较之后才递增，而不是先递增再比较。

# scanf输入前的&

![image-20210130210642382](D:\markdown\IMG\image-20210130210642382.png)

注意：scanf()只读取了Angela Plains中的Angela，它在遇到第1个空白（空格、制表符或换行符）时就不再读取输入。因此，scanf()在读取到Angela Plains之间的空格时就停止了。一般而言，根据%s转换说明，scanf()只会读取字符串中的一个单词，而不是一整句。C语言还有其他的输入函数（如：fgets()）,用于读取一般字符串。

strlen()不会将字符串末尾的空字符计入，sizeof运算符报告对声明的所有字节数统计，sizeof+变量，则不必须要sizeof()，若sizeof+类型，则需要sizeof(),例如：sizeof(int)。

scanf("%c", &cn)从输入中的第一个字符开始读取，scanf("  %c", &cn)从第一个非空白字符开始读取。

# 常量和C预处理器

## 符号常量

符号常量，#define NAME value   ,末尾不需要加“；”

## const限定符

const int MONTHS = 12;

# 副作用和序列点

副作用是对数据对象或文件的修改；序列点是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生，语句的分号和任何一个完整表达式的结束都是序列点；

while(guests++ <10)

​	printf("%d \n",guests);

表达式guests++ <10是一个完整的表达式，所以printf中使用的guests递增之后的值。

# getchar()&&putchar()

getchar()和putchar()只处理字符，是预处理宏，不是真正的函数。

![image-20210131105954847](D:\markdown\IMG\image-20210131105954847.png)

# 字符测试函数

![image-20210131110539948](D:\markdown\IMG\image-20210131110539948.png)

![image-20210131110605792](D:\markdown\IMG\image-20210131110605792.png)

# 逻辑运算符、条件运算符

## 逻辑运算符

![image-20210131110924576](D:\markdown\IMG\image-20210131110924576.png)

### 优先级

！运算符的优先级很高，比乘法运算发优先级还高，与递增运算符的优先级相同，只比圆括号的优先级低。&&运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。c保证逻辑表达式的求值顺序是从左往右，&&和||运算符都是序列点，所以整个程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。

而且，C保证一旦发现某个元素让整个表达式无效，便立刻停止求值。

while(x++ <10 && x+y <20)

实际上，&&是一个序列点，这保证了在对<u>&&右侧的表达式求值之前，已经递增了x</u>。

## 条件运算符

x=(y<0)?-y:y;

在=和；之间的内容就是条件表达式，该语句的意思是“如果y小于0，那么x=-y；否则，x=y"。

cans += ((sq_feet % COVERAGE == 0)) ? 0: 1;

该语句把+=右侧的表达式的值加上cans，再赋值给cans。右侧表达式是一个条件表达式，根据sq_feet是否能被COVERAGE整除，其值为0或1.

# Switch && break  &&  continue

break语句可用于循环和switch语句中，而continue只能由于循环中，尽管如此，如果switch语句在一个循环中，continue便可作为switch语句中的一部分。这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分。

switch在圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式（即，表达式中只包含整型常量）。不能用变量作为case标签。

break语句让程序离开switch语句，跳至switch语句后面的下一条语句。如果没有break语句，就会从<u>匹配标签开始执行到switch末尾</u>（接下来的每个case都会执行）。

goto b；

b:XXXX；

# 函数

## 函数内存分配

程序执行过程中，函数若不被使用，则只是放在代码区，若被调用，在函数被调用的地方，给函数分配内存（无论是指针函数害还是函数指针被调用时，均给函数分配栈区的内存），注意：（1）指针函数；本质是一个函数，返回值是指针；调用这个指针函数时，为这个指针函数分配内存（<u>这个内存在栈区</u>），返回的指针，指向的内容在堆区；（2）函数指针；本质是一个指针，指向函数；调用这个函数指针时候，为这个函数指针分配内存（<u>这个内存在栈区</u>）。

函数与变量不一样，变量是有的分配在栈区，有的分配在堆区；而函数统一分配在栈区，是因为函数需要一步一步的执行，栈规定了一步一步执行，而堆区没有规定一步一步执行。

![img](D:\markdown\IMG\4bef2d84-c975-4e3f-b2f6-c2f49f2b807a.jpg)

## 带形参的函数定义、声明、被调用

### 定义带形式参数的函数

形式参数也是局部变量，属于函数私有，这意味着在其他函数中使用同名变量不会引起名称冲突。

void show_n_char(char ch, int num)

### 声明带形式参数的函数原型

（1）void show_n_char(char ch, int num)；

（2）void show_n_char(char, int)

在原型中使用变量名并没有实际创建变量，实际被调用时，在调用处创建变量并分配内存。

### 调用带形式参数的函数

形式参数是被调用函数中的变量，实际参数是主调函数赋给被调用函数的具体值，实际参数可以是变量、常量，甚至是更复杂的表达式，然后该值<u>被拷贝给</u>被调用函数相应的形式参数。

## return

（1）返回值不仅可以赋给变量，也可以被用作表达式的一部分；

（2）返回值不一定是变量的值，也可以是任意表达式的值；

（3）实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值；

（4）使用return的另一个作用是，终止函数并把控制返回给主调函数的下一条语句。

## 递归

待补充。。。

## Linux

假定linux系统安装了GNU C编译器GCC，假设文件file1.ch和文件file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成名为a.out的可执行文件：

gcc file1.c file2.c

另外还生成两个名为file1.o 和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第一个文件，并与第二个文件的目标代码合并：

gcc file1.c file2.o

# 指针

指针是一个值为内存地址的变量（或数据对象），正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。

ptr = & pooh; //把pooh的地址赋值给ptr

对于这条语句，我们说ptr指向pooh。ptr和&pooh的区别是ptr是变量，而&pooh是常量。或者说，ptr是可修改的左值，而&pooh是右值，还可以把ptr指向别处。

## 间接运算符：*

‘*’运算符有时也称为解引用运算符

地址运算符：&

后跟一个变量名时，&给出该变量的地址；

地址运算符：*

后跟一个指针名或地址时，*给出储存在指针指向地址上的值。

## 声明指针

pointer ptr; // 不能这样声明指针

为什么不能这样声明？因为声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。long和float可能占用相同的存储空间，但是他们储存数字却大相径庭。

int *pi;

类型说明符表明了指针所指向对象的类型，星号*表明声明的变量时一个指针。int * pi ;声明的意思时pi时一个指针，*pi是int类型。

# 数组

## 初始化数组

数组通常被用来储存程序需要的数据；

(1)初始化方式1：

int power[8]={1,2,3,4,5,6,7,8};//在逗号和值之间可以使用空格。

(2)const 声明数组，方式2：

const int days[12]={31,28,31,30,31,30,31,31,30,31,30,31};

通过使用const声明和初始化数组，使数组为只读形式，这样，程序只能从数组中检索值，不能把新值写入数组。程序在运行过程中就不能修改该数组中的内容。

（3）初始化方式3：

int power[8]={1,2,3};

当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0，也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值。如果初始化列表的项数多于数组元素个数，编译器会将其视为错误。

### 指定初始化器

int arr[6] = {[5] = 212}; //把arr[5]初始化为212

对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0.

变长数组：VLA

## 多维数组

float rain[5] [12];//内含5个数组元素的数组，每个数组元素内含12个float类型的元素。

理解该声明的一种方法是，先查看中间部分（粗体部分）：

float **rain[5]** [12];//rain是一个内含5个元素的数组

这说明数组rain有5个元素，至于每个元素的情况，要查看声明的其余部分（粗体部分）；

**float** rain[5] **[12]**;//一个内含12个float类型元素的数组

这说明每个元素的类型是float[12],也就是说，rain的每个元素本身都是一个内含12个float类型值的数组。

## 指针和数组

数组名是数组首元素的地址，如果flizny是一个数组，下面的语句成立：

flizny == &flizny[0];//数组名是该数组首元素的地址

flizny 和&flizny[0]都表示数组首元素的内存地址（&是地址运算符）。两者都是常量，在程序运行过程中，不会改变。

### 指针加

指针加1指的是增加一个存储单元，对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址，这是为什么必须声明指针所指向对象类型的原因之一，只知道地址不够，因为计算机要知道储存对象需要多少个字节。

dates + 2 == &dates[2];//相同的地址

*（dates + 2 ）== dates[2];//相同的值

ar[n]的意思是*（ar+n）,可以认为 *（ar+n）的意思是“到内存的ar位置，然后移动n个单元，检索储存在那里的值”。

*（dates+2）和 *dates+2,间接运算符（ * ）的优先级高于 +，所以*dates+2相当于（ *dates）+2。

### 函数、数组和指针

total = sum(marbles); //可能的函数调用

记住，数组名是该数组首元素的地址，所以实际参数marbles是一个储存int类型值的地址，应把它赋给一个指针形式参数，即该参数是一个指向int的指针；

int sum(int *ar); //对应的函数原型

既然能使用指针表示数组名，也可以用数组名表示指针。

int sum(int *ar, int n)

{

​		int i;

​		int total = 0;

​		for (i=0; i<n; i++)

​				total += ar[i];//ar[i]和*（ar+i）相同

​		return total;

}

关于函数的形参，还有一点要注意。只有在<u>函数原型或函数定义头</u>中，才可以使用int ar[]代替int *ar;

int sum(int ar[], int n);

int *ar 形式和int ar[]形式都表示ar是一个指向int的指针。但是，int ar[]只能用于声明形式参数。

由于<u>函数原型</u>可以省略参数名，所以下面4种原型都是等价的：

int sum(int *ar, int n);

int sum(int *, int );

int sum(int ar[], int n);

int sum(int [], int );

但是，在函数定义中不能省略参数名。

int sum(int *ar, int n)

{

//其它代码

}

int sum(int ar[], int n)

{

//其它代码已省略

}

### 使用指针形参

函数处理数组，需要知道何时开始、何时结束。sum（）函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数，但是这并不是给函数传递必备信息的唯一方法；

还有一种方法是传递两个指针，第一个指针指明数组的开始处，第二个指针指明数组的结束处。

int main(void)
{
	int marbles[SIZE] = {20, 10, 5, 39, 4, 16, 19, 26, 31, 20};
	long answer;
	answer = sump(marbles, marbles + SIZE);//数组名也是指针
	printf("The total number of marbles is %ld.\n", answer); 
	return 0; 
	
}

int sump(int *start, int *end)
{
	int total = 0;
	while(start < end)
	{
		total += *start;//把数组元素的值加起来
		start++;        //让指针指向下一个元素 
	}
	return total; 
}

循环最后处理的一个元素是end所指向位置的前一个元素。这意味着end指向的位置实际上在数组最后一个元素的后面。C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。

total += *start;一元运算符 * 和++的优先级相同，但结合律是从右往左，所以start++先求值，然后才是*start。

至于C语言，ar[i]和*（ar+1）这两个表达式都是等价的。无论ar是数组名还是指针变量，这两个表达式都没问题。但是，只有当ar是指针变量时，才能使用ar++这样的表达式。

















